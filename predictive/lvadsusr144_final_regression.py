# -*- coding: utf-8 -*-
"""LVADSUSR144_final_Regression.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sqFdsggcC5EomkobS-AVcyNilK9f1PT-
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import LabelEncoder,MinMaxScaler
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_absolute_error,r2_score,mean_squared_error
import warnings
warnings.filterwarnings("ignore")

#data reading
data = pd.read_csv("/content/bengaluru_house_prices.csv")
data.head()

data.shape

data.info()

data.describe()

data.isnull().sum()

data.drop(columns=['society'],inplace=True)

data['area_type'].value_counts()

data.head()

for num_col in data.select_dtypes(include=['float64', 'int64']).columns:
    sns.histplot(data[num_col], kde=True)
    plt.title(f'Histogram of {num_col}')
    plt.xlabel(num_col)
    plt.ylabel('Frequency')
    plt.show()

data.dropna(inplace=True)

data.isnull().sum()

data.shape

data['size']=data['size'].str.split(' ')

data.head()

df = data[['total_sqft','bath','balcony','price']]

df.info()

df.isnull().sum()

df['total_sqft'] = pd.to_numeric(df['total_sqft'],errors='coerce')

df.isnull().sum()

df.dropna(inplace=True)

#check for outliers

for c in df.select_dtypes(include=['int64','float64']).columns:
  plt.figure(figsize=(10,10))
  sns.boxplot(df[c])
  plt.title(f"Box plot of {c}")



#correlation
plt.figure(figsize=(20,10))
sns.heatmap(df.corr(),annot=True)

x = df.drop(columns=['price'])
y=df['price']

x_train,x_test,y_train,y_test = train_test_split(x,y,test_size=0.2)

#scaling
scaler = MinMaxScaler()
x_train = scaler.fit_transform(x_train)
x_test = scaler.transform(x_test)

#model
model = LinearRegression()
model.fit(x_train,y_train)
y_pred = model.predict(x_test)

mean_squared_error(y_test,y_pred)

mean_absolute_error(y_test,y_pred)

r2_score(y_test,y_pred)

plt.scatter(y_test, y_pred, c='red', label='Actual')
plt.scatter(y_test, y_test, c='blue', label='Predicted')
plt.xlabel("Actual values")
plt.ylabel("Predicted values")
plt.plot([min(y_test), max(y_test)], [min(y_test), max(y_test)], color='black', linestyle='-', label='bestfitline')
plt.legend()